<!DOCTYPE html><html lang="en"><head><title>Graph</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="Graph"><meta name="groc-project-path" content="js/src/Graph.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-adjacency-matrix"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-adjacency-matrix/blob/master/js/src/Graph.js">js/src/Graph.js</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> Graph = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> </span>) </span>{

	<span class="hljs-keyword">this</span>.V = [ ] ;
	<span class="hljs-keyword">this</span>.E = [ ] ;

} ;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>O(n²), amortized O(n)</p>
<p><strong>Returns a vertex</strong><br/>(a vertex reference)</p></div></div><div class="code"><div class="wrapper">Graph.prototype.vadd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> </span>) </span>{

	<span class="hljs-keyword">const</span> len = <span class="hljs-keyword">this</span>.V.length ;
	<span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">new</span> Vertex( len ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>add a vertex</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">this</span>.V.push( ref ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>add a row</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">this</span>.E.push( [ <span class="hljs-keyword">for</span> ( v <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.V ) <span class="hljs-keyword">new</span> Edge( <span class="hljs-literal">null</span> , <span class="hljs-literal">null</span> ) ] ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>add a column (undirected graph:(i,j) = (j,i))</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; len ; ++j ) <span class="hljs-keyword">this</span>.E[j].push( <span class="hljs-keyword">this</span>.E[len][j] ) ;

	<span class="hljs-keyword">return</span> ref ;

} ;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>O(n²), amortized O(n)
Fast if removing vertices in LIFO order.</p>
<p>Parameters:</p>
<ul>
<li><strong>v must be a vertex.</strong><br/>(is a vertex reference)</li>
</ul></div></div><div class="code"><div class="wrapper">Graph.prototype.vdel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> v </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>id to delete</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">const</span> i = v.id ;

	<span class="hljs-keyword">const</span> len = <span class="hljs-keyword">this</span>.V.length ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>last id</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">const</span> j = len - <span class="hljs-number">1</span> ;

	<span class="hljs-keyword">if</span> ( i &lt; j ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>swap deleted row and column
with last row and column</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move vertex reference</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.V[i] = <span class="hljs-keyword">this</span>.V[j] ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>change vertex id</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.V[i].id = i ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move column</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span> ; k &lt; i ; ++k ) <span class="hljs-keyword">this</span>.E[k][i] = <span class="hljs-keyword">this</span>.E[ k ][j] ;
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> k = i ; k &lt; j ; ++k ) <span class="hljs-keyword">this</span>.E[k][i] = <span class="hljs-keyword">this</span>.E[k+<span class="hljs-number">1</span>][j] ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move row</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span> ; k &lt; i ; ++k ) <span class="hljs-keyword">this</span>.E[i][k] = <span class="hljs-keyword">this</span>.E[j][k] ;
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> k = i ; k &lt; j ; ++k ) <span class="hljs-keyword">this</span>.E[i][k] = <span class="hljs-keyword">this</span>.E[j][k+<span class="hljs-number">1</span>] ;

	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remove last vertex</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">this</span>.V.splice( j , <span class="hljs-number">1</span> ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remove last row</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">this</span>.E.splice( j , <span class="hljs-number">1</span> ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remove last column
NB : after removing row k &lt; len - 1 = j</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span> ; k &lt; j ; ++k ) <span class="hljs-keyword">this</span>.E[k].splice( j , <span class="hljs-number">1</span> ) ;

} ;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>O(1)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>u must be a vertex.</strong><br/>(is a vertex reference)</p>
</li>
<li><p><strong>v must be a vertex.</strong><br/>(is a vertex reference)</p>
</li>
<li><p><strong>w must be a weight.</strong></p>
</li>
</ul>
<p><strong>Returns an edge</strong><br/>(an edge reference)</p></div></div><div class="code"><div class="wrapper">Graph.prototype.eadd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> u , v </span>) </span>{

	<span class="hljs-keyword">const</span> i = u.id , j = v.id ;

	<span class="hljs-keyword">this</span>.E[i][j].u = u ;
	<span class="hljs-keyword">this</span>.E[i][j].v = v ;

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.E[i][j] ;

} ;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>O(1)</p>
<p>Parameters:</p>
<ul>
<li><strong>e must be an edge.</strong><br/>(is an edge reference)</li>
</ul></div></div><div class="code"><div class="wrapper">Graph.prototype.edel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> e </span>) </span>{

	e.u = <span class="hljs-literal">null</span> ;
	e.v = <span class="hljs-literal">null</span> ;

} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(n)</p></div></div><div class="code"><div class="wrapper">Graph.prototype.vitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> </span>) </span>{

	<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.V ;

} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(n²)</p></div></div><div class="code"><div class="wrapper">Graph.prototype.eitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> </span>) </span>{

	<span class="hljs-keyword">const</span> len = <span class="hljs-keyword">this</span>.V.length ;

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; len ; ++i ) {

		<span class="hljs-keyword">const</span> _e = <span class="hljs-keyword">this</span>.E[i] ;

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> j = i ; j &lt; len ; ++j ) {

			<span class="hljs-keyword">const</span> e = _e[j] ;

			<span class="hljs-keyword">if</span> ( e.u === <span class="hljs-literal">null</span> ) <span class="hljs-keyword">continue</span> ;

			<span class="hljs-keyword">yield</span> e ;

		}

	}

} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(n)</p></div></div><div class="code"><div class="wrapper">Graph.prototype.iitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

	<span class="hljs-keyword">const</span> i = v.id ;

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.E[i] ) {

		<span class="hljs-keyword">if</span> ( e.u === <span class="hljs-literal">null</span> ) <span class="hljs-keyword">continue</span> ;

		<span class="hljs-keyword">yield</span> e ;

	}

} ;

Graph.prototype.initr = Graph.prototype.iitr ;
Graph.prototype.outitr = Graph.prototype.iitr ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(n)</p></div></div><div class="code"><div class="wrapper">Graph.prototype.nitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> w </span>) </span>{

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> { u , v } <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.E[w.id] ) {

		<span class="hljs-keyword">if</span> ( u === <span class="hljs-literal">null</span> ) <span class="hljs-keyword">continue</span> ;

		<span class="hljs-keyword">yield</span> u === w ? v : u ;

	}

} ;

Graph.prototype.dsitr = Graph.prototype.nitr ;
Graph.prototype.dpitr = Graph.prototype.nitr ;

Graph.prototype.vertices = Graph.prototype.vitr ;

Graph.prototype.edges = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> </span>) </span>{

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.eitr( ) ) <span class="hljs-keyword">yield</span> [ e.u , e.v , e ] ;

} ;

Graph.prototype.incident = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.iitr( v ) ) <span class="hljs-keyword">yield</span> [ e.u , e.v , e ] ;

} ;

Graph.prototype.ingoing = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.initr( v ) ) <span class="hljs-keyword">yield</span> [ e.u === v ? e.v : e.u , v , e ] ;

} ;

Graph.prototype.outgoing = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.outitr( v ) ) <span class="hljs-keyword">yield</span> [ v , e.u === v ? e.v : e.u , e ] ;

} ;

Graph.prototype.endpoints = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> e </span>) </span>{

	<span class="hljs-keyword">return</span> [ e.u , e.v ] ;

} ;


Graph.prototype.reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> </span>) </span>{ } ;

exports.Graph = Graph ;</div></div></div></div></body></html>